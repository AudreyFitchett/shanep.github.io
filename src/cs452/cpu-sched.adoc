= Scheduling: Introduction
include::../../includes/attributes-settings.adoc[]

== Workload Assumptions

. Each job runs for the same amount of time.
. All jobs arrive at the same time.
. Once started, each job runs to completion.
. All jobs only use the CPU (i.e., they perform no I/O)
. The run-time of each job is known.

== Scheduling Metrics

* stem:[T_{turnaround} = T_{completion} - T_{arrival} ]
* Assume stem:[T_{arrival} = 0]
* Thus stem:[T_{turnaround} = T_{completion}]

== First In, First Out (FIFO)

* Most basic algorithm
* Also know as First Come, First Served (FCFS)
* Simple to implement
* Not a great performer

=== Perfect

image::images/fcfs-perfect.png[FCFS]

stem:[T_{turnaround} = \frac{10+10+10}3 = 10]

=== Bad Performance

image::images/fcfs-worst.png[Bag]

stem:[T_{turnaround} = \frac{100+110+120}3 = 110]

== Shortest Job First (SJF)

image::images/sjf.png[sjf]

stem:[T_{turnaround} = \frac{10+20+120}3 = 50]

== A New Metric: Response Time

* stem:[T_{response} = T_{firstrun} - T_{arrival} ]

=== Details

image::images/response-time.png[response time]

== Round Robin

The basic idea is simple: instead of running jobs to completion, RR runs a job
for a time slice (sometimes called a scheduling quantum) and then switches to
the next job in the run queue

== Advanced Algorithms

All the algorithms discussed are fairly simple and modern operating systems use
more advanced data structures such as a multi-level feedback queue to further
improve performance!

== Questions
