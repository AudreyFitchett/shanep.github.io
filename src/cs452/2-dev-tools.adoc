= Development Tools
include::../../includes/attributes-settings.adoc[]

== Tools

In order to work on all the projects this semester you have several options.
I have listed all the different options that you can use this semester.

. Use https://github.com/features/codespaces[Github Codespaces]
. Install Linux in a <<Virtual Machine>>
. Come in and use the Lab machines directly
. Code remotely using ssh!

=== Native Programming

* Java is cross platform
* This class is not!
* You will be calling system calls directly
* We will be using Linux

== Virtual Machine

One of the biggest barriers to getting started is to get all your tools
installed and configured correctly.  While it is certainly possible to develop
on any platform (Windows, OSX, BSD, etc.), developing on Linux is by far the
quickest and easiest method. Thus, if you want to jump right in and start writing
code without getting all your tools configured and your development machine is
not running Linux you can start developing in a Virtual machine. Once you get
some experience with the tools and process you should be able to setup any
machine to do OS development on.

== C++ ‚ò†Ô∏è

* You are welcome to use C++ in your projects as long as you provide the appropriate C bindings
* Can't use c++ to bypass the point of the assignment (linked list)

== Building üèõ

* Your project Must build from the command line
* Your project Must build on onyx AND GitHub codespaces
** Failure to compile on either will result in a 0! üíÄ

== Memory Tools

We will look at a few open source tools that you can use to help track down and
solve memory errors in C and C{pp}.  Due to the  unsafe nature of these
languages we need to be extra careful not to let latent memory bugs creep into
our code. Luckily, there have been lots of tools developed over the years that
can help us track down these errors.

While it may be tempting to just eschew C and C{pp}  for a more modern language
that has reduced or eliminated these types of errors, that may not always be
practical because of your working domain. For example, some micro controllers
may have an instruction set architecture (ISA) that a newer language such as
Rust can't even generate code for, so your ony choice is to use the software
development kit (SDK) that is provided by the manufacturer which is most
certainly written in C!

Finally, even if everyone in the world stopped creating any *new* projects in C
and C{pp} there are still *billions* of lines of existing C and C{pp} code that
can't be replaced overnight. So the need to maintain, update, and port existing
C and C{pp} code bases will remain an active area of development for the
forseeable future.

=== Address sanitizer

According to the LLVM documentation
https://clang.llvm.org/docs/AddressSanitizer.html[Address Sanitizer] is a fast
memory error detector. It consists of a compiler instrumentation module and a
run-time library. Address sanitizer should
https://www.openwall.com/lists/oss-security/2016/02/17/9[not be used in
production], it is a development tool to help the engineer track down memory
issues when developing code or tracking down elusive bugs.

One of the best uses of address sanitizer is to use it while unit testing your
code to make sure and catch any low hanging fruit. The tool can detect the
following types of bugs:

* Out-of-bounds accesses to heap, stack and globals
* Use-after-free
* Use-after-return (clang flag -fsanitize-address-use-after-return=(never|runtime|always) default:
runtime)
* Enable runtime with: ASAN_OPTIONS=detect_stack_use_after_return=1
* Use-after-scope (clang flag -fsanitize-address-use-after-scope)
* Double-free, invalid free
* Memory leaks (experimental and currently only on linux)

Here is an example of using address sanitizer (from the llvm docs):

[,c]
----
% cat example_UseAfterFree.cc
int main(int argc, char **argv) {
  int *array = new int[100];
  delete [] array;
  return array[argc];  // BOOM
}

# Compile and link
% clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer example_UseAfterFree.cc
----

=== Valgrind

https://valgrind.org/[Valgrind] is an awesome tool that can detect
https://github.com/google/sanitizers/wiki/AddressSanitizerComparisonOfMemoryTools[most,
but not all], of the same type of errors that Address Sanitizer can. The biggest
difference is Valgrind doesn't have to be compiled into your binary, so if you
don't have the source code to a particular component you can still debug issues
with Valgrind. Valgrind acts as a virtual machine that dynamically recompiles
the code during runtime. This adds considerable overhead to your program and can
slow down execution by as much as 20x. While Valgrind can't detect all errors it
can help you track down read/write errors and memory leaks without having to
recompile your executable. This is nice if you have a nasty bug that only shows
up in a release build but disappears in debug builds.

You should not use Valgrind on executables that are already compiled with
address sanitizer. You will not get _better_ detection it will just slow down
your code even more and make your life more difficult. A good approach is to use
Address Sanitizer on debug builds and Valgrind on release builds where address
sanitizer has been disabled.

After you run your program Valgrind will report any leaks or errors after your
program exits.

[,bash]
----
All heap blocks were freed -- no leaks are possible
ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
----

Anything else in the valgrind output indicates that you have an error and it
must be fixed no matter how minor.

=== Avoid shooting yourself in the foot

One of the easiest ways to prevent memory related errors is to just avoid (to
the greatest extent possible) some of the more dangerous and poorly designed
parts of C and the C standard library. Remember that C was invented in a simpler
time and was a vast improvement over writing raw assembly at the time. So while
some things may seem obvious now, remember we have the advantage of hindsight!

In the last 40+ years much has been learned about writing secure code and we
should take advantage of those lessons learned. While it would be great to just
remove all the legacy cruft and start new, there is simply too much code in the
world that still depends on some unsafe and poorly designed API's. So while we
can't remove the old cruft, we can still avoid using anything dangerous in any
*new* code that is written.

== References

* xref:../../articles/coverity-acm.pdf[Coverity]