= Project 4
include::../../../includes/attributes-settings.adoc[]

== Overview

In this lab, you are tasked with taking an existing data structure that is not
thread safe and wrapping it to use in a multi-threaded environment. In industry
you may be tasked with modifying legacy code to work in a multi-threaded
environment so this is a critical skill to master while in school ðŸ˜ƒ.

You are given an existing implementation of merge sort. This implementation is
derived directly from the book "Introduction to Algorithms" by Cormen,
Leiserson, Rivest, and Stein. Your job is to wrap this algorithm so you can use
it in a multi-threaded environment.

image::./images/yunowork.jpeg[UYNoWork, align="center"]

## Task 1 - Make Thread safe

Read through the files `lab.h` and `lab.cpp` shown below to make sure you
understand the algorithm. You are not allowed to modify the single threaded
implementation in  you must implement the function `mergesort_mt`. Your
implementation needs to split up the array into equal chunks and then hand each
chunk to a new thread. You will then use `pthread_join` to wait for all the
chucks to be sorted at which point you will need to merge the results together.
You will not need to use locks for this approach because you are taking a large
array and splitting it up between threads so each thread only operates on its
section of the larger array. C pointers come in really handy for this approach
because you can keep the original array in place and just declare new pointers
into separate chunks of the existing array.

- https://computing.llnl.gov/tutorials/pthreads/[pthread tutorial]
- http://pages.cs.wisc.edu/~remzi/OSTEP/threads-intro.pdf[Intro to Threads]
- http://pages.cs.wisc.edu/~remzi/OSTEP/threads-api.pdf[Threads API]

## Task 2 - Driver app

Once you have completed writing the multi-threaded version of the code you will
need to test your code with a simple command line driver that will take two
command line arguments and output the number of threads used and the total time
to sort the array as shown in the example below. You should see a speed up when
you increase the number of threads used to sort the array. However, if you add
too many threads you will see a slow down because of the overhead of context
switching between threads. You will need to experiment with the number of
threads to see what the optimal number is for your machine and document that in
your Retrospective.md file.

[,bash]
----
usage: ./myprogram <array_size> <num_threads>
$ ./myprogram 1000 2
0.0820312 2
$ ./myprogram 1000 3
0.104004 3
----


== Starter Code

Each link block below is the starter code that you must use for this project.
In your project you will need to find the files and replace them with what is
shown below.

* https://gist.github.com/shanep/ae42dbe844bd930da86cc3ae3e5f5d79[src/lab.h]
* https://gist.github.com/shanep/398f0cefb604697077275942888661f0[src/lab.cpp]
* https://gist.github.com/shanep/1d34526608c210634629a750c2665735[tests/test-lab.cpp]
