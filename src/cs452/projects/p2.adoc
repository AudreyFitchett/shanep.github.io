= Project 2
include::../../../includes/attributes-settings.adoc[]

== Overview

In this project, we will be implementing a simple shell that can start
background process using the examples that were presented in chapter 5.

WARNING: This project is requires significant time to complete if you are using
windows. If you are using windows you should start early and expect to spend at
least 10 additional hours. It is **strongly recommend** that you complete this
project on a Linux machine and only attempt windows once you have a fully
working Linux version.

== Learning Outcomes

* 1.2	 Use system library code
* 1.3	 Use system documentation
* 1.4	 Apply computer science theory and software development fundamentals to produce computing-based solutions. **(ABET Outcome 6)**
* 2.2	 Explore the system call interface

== Additional Resources

Below are some links to some awesome documentation for writing a job control
shell which you should read through before you start coding as it will help you
understand the problem space.  However, be aware that the libc manual describes
a much more complex shell than what we are building so don't panic if you don't
understand everything in the manual.

Keep in mind that some of the code samples provided in the libc manual are
written in C89 so may look a bit strange if you are used to only reading C99
code.

* https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf[chapter5]
* https://www.gnu.org/software/libc/manual/html_node/Implementing-a-Shell.html[glibc
manual]

== Task 1 - Print Version

Let's start off simple and just have our shell print off its version. When the
shell is started with a command line argument -v, it prints out the version of
the project and then quits, you will need to leverage the header file
`labconfig.h` for the major and minor version. Parse the command line arguments
with
https://www.gnu.org/software/libc/manual/html_node/Example-of-Getopt.html[getop].
The program should exit after printing the version.

== Task 2 - User Input

While we could use a function like
https://cplusplus.com/reference/cstdio/scanf/[scanf] to get input from the user
a much more robust way would be to leverage the
https://tiswww.case.edu/php/chet/readline/rltop.html[GNU Readline library]. The
GNU Readline library allows a program to control the input line and adds a bunch
of cool functions that allow the user to edit the line, use TAB key for filename
completion, and the use of up arrow, down arrow, left arrow and right arrow keys
to access the history of commands typed in by the user. You will need to include
the header files `readline/readline.h` and `readline/history.h` to use the
readline functions.

[,c]
----
#include <readline/readline.h>
#include <readline/history.h>

char *line;

using_history();
while ((line=readline("$"))){
    printf("%s\n",line);
    add_history(line);
    free(line);
}
----

IMPORTANT: You need to install both the readline header files and development
libraries for the above code to compile and link. All the correct libraries are
installed on the lab machines. On Redhat based machines development packages
end in devel. So to get all the readline development packages you would need
to install **readline-devel** as well as **readline**. On ubuntu the development files
are named **readline-dev**.

The readline documentation is a good starting point on how to use the readline
library. Pay close attention to memory ownership. Remember that C does not have
a garbage collector.

- https://tiswww.cwru.edu/php/chet/readline/readline.html[Readline Docs]
- https://tiswww.cwru.edu/php/chet/readline/history.html[History Docs]

== Task 3 - Custom Prompt

The default prompt for the shell may be anything you like. However the shell
checks for an environment variable `MY_PROMPT`. If the environment variable is
set, then it uses the value as the prompt. The environment variable can be set
inline  `MY_PROMPT="foo>" ./myprogram` so you can quickly test your program.

- Use the system call
  https://man7.org/linux/man-pages/man3/getenv.3.html[getenv] to retrieve
  environment variables

== Task 4 - Built in Commands

Now that we can get input from users lets add in some built in commands. These
commands need to be handled by the shell itself, you should not create a new
process to handle these commands so it is good to implement these **before**
you add in the fork/exec code in a future task.

=== Exit command

Include a built-in command named `exit` that terminates the shell normally. Your
shell should return a status of 0 when it terminates normally and a
non-zero status otherwise. Your shell should also terminate normally on
receiving the end of input https://en.wikipedia.org/wiki/End-of-file[EOF]
(Under Linux and bash, this would normally be Ctl-d for you to test your
mini-shell). You are required to clean up any allocated memory before you exit.

- https://man7.org/linux/man-pages/man3/exit.3.html[exit]

=== Change Directory Command

Include a built-in command named `cd` to allow an user to change directories.
You will need to use the `chdir` system call. The `cd` command without any
arguments should change the working directory to the user's home directory. You
must first use `getenv` and if `getenv` returns NULL your program should fall
back to the system calls `getuid` and `getpwuid` to find out the home directory
of the user. Make sure to print an error message if the cd command fails.

- See https://man7.org/linux/man-pages/man2/chdir.2.html[chdir]
- See https://man7.org/linux/man-pages/man3/getenv.3.html[getenv]
- See https://man7.org/linux/man-pages/man2/getuid.2.html[getuid]
- See https://man7.org/linux/man-pages/man3/getpwuid.3p.html[getpwuid]

=== History Command

Add a new built in command to your shell to print out a history of command
entered. You should leverage the
https://tiswww.cwru.edu/php/chet/readline/history.html[history library] library
to accomplish this.

== Task 5 - Create a Process

Our shell will create a new process and wait for it to complete. The shell
accepts one command per line with arguments. It should accept at least `ARG_MAX`
arguments to any command. You will need to use the system call `sysconf` and
`_SC_ARG_MAX` to get the maximum length of arguments that the the `exec` family
of functions can accept. The shell will parse each line that is entered and then
attempt to execute the process using the `execvp` system call. The `execvp`
system call performs a search for the command using the `PATH` environment
variable. This will simplify your programming since you do not have to search
for the location of the command.

For our simple shell you can assume that all command line arguments will be
separated by spaces, you don't have to worry about quoted arguments. For example
given the command `ls -l -a` you would parse this string as an array of size 3
with the structure of `ls` -> `-l` -> and `-a`. The command `ls "-l -a"` would
parse out to be `ls` -> `"-l` -> `-a"`. If you want to write a parsing algorithm
that handles quotes like bash more information is available at
https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_03.html[the linux
documentation project].

If the user just presses the Enter key, then the shell displays another prompt.
If the user types just spaces and then presses the Enter key, then the shell
displays another prompt as this is also an empty command. Empty commands should
not cause a segfault or memory leak.

- https://man7.org/linux/man-pages/man3/exec.3.html[execvp]
- https://man7.org/linux/man-pages/man2/fork.2.html[fork()]
- https://man7.org/linux/man-pages/man2/wait.2.html[waitpid()]

=== Signals

The shell should ignore the signals listed below:

```c
signal(SIGINT, SIG_IGN);
signal(SIGQUIT, SIG_IGN);
signal(SIGTSTP, SIG_IGN);
signal(SIGTTIN, SIG_IGN);
signal(SIGTTOU, SIG_IGN);
```

In the child process don't forget to set these signals back to default!

```c
/*This is the child process*/
pid_t child = getpid();
setpgid(child, child);
tcsetpgrp(sh.shell_terminal,child);
signal (SIGINT, SIG_DFL);
signal (SIGQUIT, SIG_DFL);
signal (SIGTSTP, SIG_DFL);
signal (SIGTTIN, SIG_DFL);
signal (SIGTTOU, SIG_DFL);
execvp(cmd[0], cmd);
fprintf(stderr, "exec failed\n");
```

If there is no process being executed, then the shell should just display a new
prompt and ignore any input on the current line. You will need to use the
tcgetpgrp and tcsetpgrp system calls to get and set the foreground process group
of the controlling terminal and the signal system call to ignore and enable
signals.

The glibc manual links below describe a full job control shell. You are not
required to implement a job control shell to the same level of functionality.
You can  to use the documentation linked below as a guide but be aware you shell
will probably fail to function correctly if you just copy and paste the code
examples without understanding what they do. You are free to use code from the
manual as long as you take the time to understand what it does and why.

- https://www.gnu.org/software/libc/manual/html_node/Initializing-the-Shell.html[glibc - Initializing the Shell]
- https://www.gnu.org/software/libc/manual/html_node/Launching-Jobs.html[glibc - Launching Jobs]
- https://man7.org/linux/man-pages/man7/signal.7.html[Signal man page]

== Task 6 - Background Processes

Your shell can start a process in the background if an ampersand(&) is the last
character on the line. For each background process that is started, it prints
an id and the process id (pid) of the background process and the full command
that was given by the user. After starting a background process, the shell
comes back with a prompt ready to accept a new command from the user without
waiting for the background process to finish.  The user should not be required
to separate the & from the command by a space. For example, the commands date &
and date& are both valid. Additionally, blanks after the ampersand are valid as
well.

The mini shell should keep track of process running in the background. Whenever
the user starts a process in the background, it should assign and display the job
number, the associated process id and the full command (including the
ampersand).

`[n] process-id command`

It should also display an informative message when a background job is done.
That is, every time the user presses the ENTER key, the shell should report all
the background processes that have finished since the last time the user pressed
the ENTER key.  The message should be of the following form:

`[n] Done command`

Where n is the job number and command is the actual command that was typed.  You
should use the WNOHANG option with the waitpid system call to determine the
status of background processes.

== Task 7 - Jobs command

Add a new built-in command called jobs, that prints out all the background
commands that are running or are done but whose status has not yet been
reported.  Here is a sample output:

```bash
[1] 3451 Running sleep 100 &
[2] Done    sleep 5 &
[3] 3452 Running gargantuan &
```

The first job should be assigned the job number 1. Each additional job should be
assigned one higher number. If lower numbered jobs finish, then we do not reuse
them unless all jobs numbered higher than that number have also finished.
