= Debugging C and C++
include::../../includes/attributes-settings.adoc[]


== Dumping deadlocked threads with GDB
:tags: ["debugging"]

When you are working on multi-threaded programs it is pretty easy to get into a
deadlocked scenario. Debugging multi-threaded programs can be difficult because
running your program under the debugger can change the timing of your code and
thus make the issue go away. So sometimes the only way to see where your program
is stuck is to attach a debugger post mortem and dump out the threads.

So assuming you have a program that you ran and it is currently stuck somewhere
here are the steps to at least see where it is stuck which can help you fix the
issue!

=== Get the PID of the process

Before you attach a debugger you want to confirm that your program is completely
stopped and you want to get the pid of the program so you can attach to it. Open
up a second terminal and run the command `ps ux` and look for your program. If
you can't find your program you can try `ps aux` which will output all users. If
you still cant find it make sure that your program hasn't exited. *NOTE:* You
can not attach to another users program unless you have access to the root
account, you can only attach to your programs.

In the example below you can see the program `./mylab -c 3 -p 8 -i 100 -s 5`
with PID *254167* is what we want to debug.

[,bash]
----
[shanepanter@onyx:~]
$ ps ux
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
shanepa+  46764  0.0  0.0 1178788    0 ?        S     2020   0:00 /bin/bash
shanepa+ 129368  0.0  0.0 182776  2632 ?        S    10:02   0:01 sshd: shanepanter@pts/32
shanepa+ 129377  0.0  0.0 127848  3864 pts/32   Ss   10:02   0:02 -bash
shanepa+ 154093  0.0  0.0 1178792    0 ?        S     2020   0:00 /bin/bash
shanepa+ 240623  0.0  0.0 1178788    0 ?        S     2020   0:00 /bin/bash
shanepa+ 254167  0.1  0.0 590304   828 pts/32   Sl+  11:36   0:00 ./mylab -c 3 -p 8 -i 100 -s 5
shanepa+ 254357  0.0  0.0 182776  2472 ?        S    11:36   0:00 sshd: shanepanter@pts/6
shanepa+ 254358  0.5  0.0 127716  3536 pts/6    Ss   11:36   0:00 -bash
shanepa+ 254514  0.0  0.0 166156  2392 pts/6    R+   11:36   0:00 ps ux
----

=== Attach to the process

In the same terminal that you ran the `ps ux` command start gdb and attach to
the process  with the PID that you found in step 1. Once you have attached to
the process issue the command `thread apply all bt` where `bt` stands for
backtrace applied to all the current threads.

The example below shows that we have 4 threads. Thread 1 is the main thread and
we can see that it is waiting on a `pthread_join` which is expected so we don't
need to worry about Thread 1. Thread 2, 3, and 4 are all blocked on a condition
variable and we can see in the stack trace they are all stuck in the `dequeue`
function.

[,bash]
----
[shanepanter@onyx:~]
$ gdb
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
(gdb) attach 254167
Attaching to process 254167
Reading symbols from /home/ShanePanter/repos/shanep.github.io/os/labs/lab2/_solution/mylab...done.
Reading symbols from /lib64/libpthread.so.0...(no debugging symbols found)...done.
[New LWP 254178]
[New LWP 254177]
[New LWP 254176]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
Loaded symbols for /lib64/libpthread.so.0
Reading symbols from /lib64/libc.so.6...(no debugging symbols found)...done.
Loaded symbols for /lib64/libc.so.6
Reading symbols from /lib64/ld-linux-x86-64.so.2...(no debugging symbols found)...done.
Loaded symbols for /lib64/ld-linux-x86-64.so.2
Reading symbols from /lib64/libgcc_s.so.1...(no debugging symbols found)...done.
Loaded symbols for /lib64/libgcc_s.so.1
0x00007f067f11e017 in pthread_join () from /lib64/libpthread.so.0
Missing separate debuginfos, use: debuginfo-install glibc-2.17-317.el7.x86_64 libgcc-4.8.5-44.el7.x86_64
(gdb) thread apply all bt

Thread 4 (Thread 0x7f06767fc700 (LWP 254176)):
#0  0x00007f067f120a35 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0
#1  0x00000000004014a0 in dequeue (q=0x2066010) at queue.c:97
#2  0x0000000000400e55 in consumer (args=0x0) at lab.c:76
#3  0x00007f067f11cea5 in start_thread () from /lib64/libpthread.so.0
#4  0x00007f067ee4596d in clone () from /lib64/libc.so.6

Thread 3 (Thread 0x7f0675ffb700 (LWP 254177)):
#0  0x00007f067f120a35 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0
#1  0x00000000004014a0 in dequeue (q=0x2066010) at queue.c:97
#2  0x0000000000400e55 in consumer (args=0x0) at lab.c:76
#3  0x00007f067f11cea5 in start_thread () from /lib64/libpthread.so.0
#4  0x00007f067ee4596d in clone () from /lib64/libc.so.6

Thread 2 (Thread 0x7f06757fa700 (LWP 254178)):
#0  0x00007f067f120a35 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0
#1  0x00000000004014a0 in dequeue (q=0x2066010) at queue.c:97
#2  0x0000000000400e55 in consumer (args=0x0) at lab.c:76
#3  0x00007f067f11cea5 in start_thread () from /lib64/libpthread.so.0
#4  0x00007f067ee4596d in clone () from /lib64/libc.so.6

Thread 1 (Thread 0x7f067f534740 (LWP 254167)):
#0  0x00007f067f11e017 in pthread_join () from /lib64/libpthread.so.0
#1  0x0000000000401151 in main (argc=9, argv=0x7fff5b567418) at lab.c:176
(gdb)
----

=== Debug it

Now that we at least know *where* our process is stuck we can exam the code and
come up with all the ways that this scenario could occur. Be aware that the
issue may not be in the `dequeue` function! More likely than not the bug is
somewhere else entirely. All this does is give you some insight into where your
program is getting stuck *NOT* where the problem is!

== References

* xref:../../articles/modern-debugging-acm.pdf[Modern Debugging]