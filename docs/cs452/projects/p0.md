# Project 0

![P0 Meme](images/p0-meme.jpeg)

This project is intended to serve as an introduction to the project template,
build tools, and process to complete projects during this semester. This project
demonstrates the only **officially** supported tools and programming languages
supported.

This project is divided into several tasks. Each task will be explained in
detail and you are expected to complete each task in order. This project has
been tested on Linux, Windows, and MacOS using github actions. In _theory_ you
could use any operating system you wish to develop and test your solution.
However, the reality of writing native cross platform code is a quagmire of
sadness and despair. Additionally, supporting 3 operating systems and their
respective development environments is beyond the capacity of your instructor
and GA/TA. This project is configured for
[VSCode](https://code.visualstudio.com/) and should work out of the box with
[Github Codespaces](https://github.com/features/codespaces) and the computers
in the KOUNT learning center.

Students get a free [Github Pro](https://education.github.com/pack) account as
long as you sign up with your Boise State email address. This will allow you to
use Github Codespaces for free in this class. If you run out of free hours on
codespaces you can use the CS department lab machines to complete the project.
You are NOT required to pay for a Github Pro account to complete this project.

**NOTE:** While students are encouraged to setup their own machine to work on
the project, the instructor and TA/GA will not be able to provide any support
for personal machines. The only supported environment is github codespaces or
the CS department lab machines.

## Learning Outcomes

- 5.1 Use a cross platform build system (win32, posix)
- 5.2 Use a professional unit test framework  (win32, posix)
- 5.3 Use a professional version control system (git)
- 5.4 Explore compiling and running code on at least 2 different systems
- 5.5 Explore how to setup a continuous integration and testing project

## Instructor support systems

Your instructor and GA/TA will support the Kount Lab, Onyx and GitHub
codespaces. If you are working in the lab follow the instructions in the
[CS Lab](https://github.com/shanep/cs452-project-starter/blob/master/README-KOUNT-LAB.md)
document. Otherwise you can use
[GitHub Codespaces](https://docs.github.com/en/codespaces/getting-started/quickstart)
to work on your projects.

## VSCode Notes

The VSCode CMake extension (2023-10-17) does not support all the features of
cmake presets that this project uses so if you run into any issues you can
update your settings.json file so that the extension does not complain about the
new features we are using.`"cmake.allowUnsupportedPresetsVersions": true`.

- [VSCode Tips and Tricks](/teaching/vscode-tips-and-tricks.md)
- [VSCode Settings](https://code.visualstudio.com/docs/getstarted/settings)




## Debugging Pointers

In the C programming language we can allocate a chunk of memory on the
heap and treat that chunk of memory as an array. If you are working on
debugging a problem and want to inspect the contents of the array using
the GUI debugger interface in VSCode you may have to tell the debugger
(with a cast) that a pointer is actually pointing to a dynamically
allocated array not a single variable. This example walks through how to
display a pointer as an array that is embedded within a struct.

More reading about C and GDB.

- [Reading C Declarations](http://unixwiz.net/techtips/reading-cdecl.html)
- [GDB Artificial Arrays](https://sourceware.org/gdb/current/onlinedocs/gdb/Arrays.html)
- [GDB to LLDB usage](http://lldb.llvm.org/use/map.html)
- [VSCode Data inspection](https://code.visualstudio.com/docs/editor/debugging#_data-inspection)

### Dynamic array of structs

Consider the struct declaration `buddy_pool` shown below. The `avail`
member is a pointer that we must dynamically allocate and want to
display in the debugger as an array. We can allocate the a `buddy_pool`
struct (in the stack or data segment) and then dynamically allocate the
`avail` array using `malloc`.

```c
struct avail
{
    int tag;
    int kval;
    struct avail *next;
    struct avail *prev;
}
struct buddy_pool
{
    size_t kval_m;
    uintptr_t base;
    struct avail *avail; /*pointer to the start of the avail array*/
};
struct buddy_pool pool;
pool.kval = 9;
pool.base = 0;
pool.avail = malloc(sizeof(struct avail) * 9);
```

If we run the debugger we will see the variable `pool` with the element
`avail` is displayed as a single variable not an array of 9 structs as
we expected.

![Pointer not showing the full array](images/pointer_as_array_bad.png)

The element `avail` is just a pointer to the memory address of element
and the debugger can’t determine the size of the array and thus will
display it as a single struct instead of an array as expected.

### Cast the array

Fortunately, all is not lost! Most debuggers allow you to set a watch on
a memory location and you can force the debugger to cast the memory to a
certain type. Both gdb and lldb have specific commands to display a
memory block as an array. However, using casting works regardless of
what debugger you are using.

If we add a new
[watch](https://code.visualstudio.com/docs/editor/debugging#_data-inspection)
on a variable and then force the debugger to display the memory block as
an array instead of a single variable we can easily inspect the data and
track down any issues you are experiencing.

`(struct avail(*) [9])pool->avail`

![Watch var showing the full array](images/setting_watch_vscode.gif)

### Dynamic Array

For a plain old dynamic array you can add a watch expression that is set
to to the desired type.

`*(int(*)[10])A`


<!--@include: ../../../parts/project-boiler.md-->

## Task 1 - Understand Starter Code

This project is setup with a sample `src/lab.h`, `src/lab.cpp`, and
`tests/test-lab.cpp` file to demonstrate how to structure your code and tests.
This project template includes intentional errors in the code and tests to
demonstrate how address sanitizer can help you find bugs in your code. Run the
following commands to see everything in action!

```bash
cmake --preset x64-ASan
cmake --build --preset x64-ASan
```

You should see a bunch of warnings in the output (which is bad), your code
should have no warnings.

```bash
/home/shanep/repos/cpp-project-template/src/lab.cpp:14:16: warning: unused parameter ‘argc’ [-Wunused-parameter]
   14 | int myMain(int argc, char **argv)
      |            ~~~~^~~~
/home/shanep/repos/cpp-project-template/src/lab.cpp:14:29: warning: unused parameter ‘argv’ [-Wunused-parameter]
   14 | int myMain(int argc, char **argv)
```

You can run the executable like this:

```bash
$ ./out/build/x64-ASan/myprogram
What is your name?shane
Hello shane! This is the starter template version: 0.1
```

You can see the tests in action like this:

```bash
$ ctest --preset x64-ASan
Test project /Users/shane/repos/yaag/test_repos/cs452-p0-starter/out/build/x64-Debug
    Start 1: SegFaultTest.asan
1/3 Test #1: SegFaultTest.asan ................***Exception: SegFault  0.00 sec
    Start 2: OutOfBoundsTest.fail
2/3 Test #2: OutOfBoundsTest.fail .............***Not Run (Disabled)   0.00 sec
    Start 3: LeakTest.fail
3/3 Test #3: LeakTest.fail ....................***Not Run (Disabled)   0.00 sec

0% tests passed, 1 tests failed out of 1

Total Test time (real) =   0.01 sec

The following tests did not run:
          2 - OutOfBoundsTest.fail (Disabled)
          3 - LeakTest.fail (Disabled)

The following tests FAILED:
          1 - SegFaultTest.asan (SEGFAULT)
Errors while running CTest
Output from these tests are in: /Users/shane/repos/yaag/test_repos/cs452-p0-starter/out/build/x64-Debug/Testing/Temporary/LastTest.log
Use "--rerun-failed --output-on-failure" to re-run the failed cases verbosely.
```

You can see there are two disabled tests. They are disabled because they fail,
lets run them anyway!

```bash
$ ./out/build/x64-ASan/test-lab --gtest_filter=DISABLED_OutOfBoundsTest.fail --gtest_also_run_disabled_tests
Running main() from /builddir/build/BUILD/googletest-1.13.0/googletest/src/gtest_main.cc
Note: Google Test filter = DISABLED_OutOfBoundsTest.fail
[==========] Running 1 test from 1 test suite.
[----------] Global test environment set-up.
[----------] 1 test from DISABLED_OutOfBoundsTest
[ RUN      ] DISABLED_OutOfBoundsTest.fail
=================================================================
==171560==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7f4241500034 at pc 0x7f424425955a bp 0x7ffd10d43490 sp 0x7ffd10d43488
WRITE of size 4 at 0x7f4241500034 thread T0
...
...
Address 0x7f4241500034 is located in stack of thread T0 at offset 52 in frame
    #0 0x7f4244259359 in outOfBounds /home/shanep/repos/cpp-project-template/src/lab.cpp:61

  This frame has 1 object(s):
    [32, 52) 'arr' (line 62) <== Memory access at offset 52 overflows this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-overflow /home/shanep/repos/cpp-project-template/src/lab.cpp:66 in outOfBounds
Shadow bytes around the buggy address:
  0x7f42414ffd80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x7f42414ffe00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x7f42414ffe80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x7f42414fff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x7f42414fff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x7f4241500000: f1 f1 f1 f1 00 00[04]f3 f3 f3 f3 f3 00 00 00 00
  0x7f4241500080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x7f4241500100: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x7f4241500180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x7f4241500200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x7f4241500280: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==171560==ABORTING
```

Play around with the project, see if you can get both of the disabled tests to
pass before you move on to the next task. NOTE: Fixing the failing tests is not
part of you grade, it is just for fun. If you are against having fun you can
skip ahead to Task 2, but be warned skipping fun may make you sad 😢.

## Task 2 - Fix the build

You need to fix all the issues in the project. There should be no build
warnings, no disabled tests, and everything should pass.

### Address sanitizer

This project is configured out of the box to use address sanitizer. To compile
your project with Address Sanitizer use the `x64-ASan` preset. [Address
Sanitizer](https://clang.llvm.org/docs/AddressSanitizer.html) is a fast memory
error detector that is compiled into the application binary. It consists of a
compiler instrumentation module and a run-time library. Address sanitizer should
[not be used in production](https://www.openwall.com/lists/oss-security/2016/02/17/9), it is a
development tool to help the engineer track down memory issues when developing
code or tracking down elusive bugs.

One of the best uses of address sanitizer is to use it while unit
testing your code to make sure and catch any low hanging fruit. The tool
can detect the following types of bugs:

- Out-of-bounds accesses to heap, stack and globals
- Use-after-free
- Use-after-return (clang flag
    -fsanitize-address-use-after-return=(never|runtime|always) default:
    runtime)
- Enable runtime with:
    ASAN\_OPTIONS=detect\_stack\_use\_after\_return=1
- Use-after-scope (clang flag -fsanitize-address-use-after-scope)
- Double-free, invalid free
- Memory leaks (experimental and currently only on linux)

## Task 3 - Code coverage

Add enough tests beyond what the professor has given you to get as close to 100%
code coverage as possible. You can run the code coverage like this:

```bash
cmake --preset x64-Coverage
cmake --build --preset x64-Coverage
```

You can view the code buy opening the file `out/build/x64-Coverage/coverage/index.html`
in your browser. The report will detail what lines of code are covered by your
tests and what lines are not covered. You can use this information to help you
write more tests to ensure you have good coverage!

Certain functions like `myMain` do not need a unit test. You can ignore these
by adding at comment `// LCOV_EXCL_START` before the function and a comment
`// LCOV_EXCL_STOP` after the function. This will tell the code coverage tool
to not include that function in the report. You can see an example of this in
`src/lab.cpp`. Remember that you can only exclude functions that are explicitly
called out in the README.md file.

## Task 4 - Write Unit tests

The starter code included a base set of tests to help guide you to the correct
solution. Using the existing tests as a guide you need to think of some cases
that are not covered by the existing tests and write some additional tests. At
this point the tests should fail, thats ok because you have not written any code
yet, in the next task you will write the code to make the tests pass. This
approach is called [Test Driven
Development](https://en.wikipedia.org/wiki/Test-driven_development) and it is a
very powerful tool for writing high quality code.

At a minimum try to add at least 1 test for each function defined in
`src/lab.h`. You may come back and add more tests later when you start working
on the next task. Writing tests first helps you think about what the functions
should do before you jump into writing the code.

You can run your tests like this:

```bash
cmake --preset x64-ASan
cmake --build --preset x64-ASan
ctest --preset x64-ASan
```

## Task 5 - Complete the Retrospective

Once you have completed everything open the file **Retrospective.md** and
complete each section that has a TODO label. You will need to add your name and
email address to the top of the file or your project will not be graded.

## Task 6 - student.toml

The last thing you need to do is update the `student.toml` file with your name
and Boise State email address.

## Task 7 - Add, Commit, Push your code

Once you are finished you need to make sure that you have pushed all your code
to GitHub for grading! You can do this by running the following commands in the
root of your project directory. You can run `git status` to see what files have
changed since the last commit.

```bash
git add .
git commit -m "My project is finished"
git push
```
